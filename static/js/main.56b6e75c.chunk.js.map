{"version":3,"sources":["../node_modules/pdfjs-dist/build sync","App.js","serviceWorker.js","index.js","logo.svg"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","PdfJsLib","GlobalWorkerOptions","workerSrc","App","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","docs","progress","zip","JSZip","maxDownloadFiles","input","React","createRef","addTextToZip","bind","assertThisInitialized","downloadZip","handleTryOnClick","handleDownloadOnClick","current","value","_this2","url","_URLParse","URLParse","hostname","path","feed","concat","slice","fetch","method","then","response","setState","json","jsonFeed","flatMap","doc","url_fulltext","manifests","console","log","forEach","manifest","retrieveManifest","generateAsync","type","blob","saveAs","err","label","texts","_this3","Promise","all","map","promise","catch","textChunks","text","join","toConsumableArray","file","manifestUri","uri","_this4","Manifesto","create","data","getSequences","seq","getRenderings","rendering","options","resource","__jsonld","flat","pdfFiles","pdfFile","getDocument","pdf","Array","_pdfInfo","numPages","pageNumber","getPage","pdfPage","getTextContent","textContent","items","str","react_default","a","createElement","min","max","className","src","logo","alt","ref","onClick","href","Component","Boolean","window","location","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister","__webpack_require__","p"],"mappings":"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","file":"static/js/main.56b6e75c.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 16;","import { parse as URLParse } from \"url\";\nimport React, { Component } from 'react';\n\nimport PdfJsLib from 'pdfjs-dist';\nimport JSZip from 'jszip';\nimport saveAs from 'file-saver';\n\nimport flat from 'array.prototype.flat';\nimport Manifesto from 'manifesto.js';\n\n\nimport logo from './logo.svg';\nimport './App.css';\n\nPdfJsLib.GlobalWorkerOptions.workerSrc = '//cdnjs.cloudflare.com/ajax/libs/pdf.js/2.0.943/pdf.worker.js';\n\nconst getPDFsFromIIIFManifest = uri => fetch(uri, { method: 'GET' })\n  .then(response => Manifesto\n    .create(response.json().data)\n    .getSequences()\n    .map(seq => seq\n      .getRenderings()\n      .map(rendering => ({\n        label: rendering.options.resource.__jsonld.label,\n        uri: rendering.id\n      }))\n    )\n  ).then(flat);\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      docs: [],\n      progress: null\n    }\n    this.zip = new JSZip();\n    this.maxDownloadFiles = 5;  // max is limited to 100 by searchworks\n    this.input = React.createRef();\n    this.addTextToZip = this.addTextToZip.bind(this);\n    this.downloadZip = this.downloadZip.bind(this);\n    this.handleTryOnClick = this.handleTryOnClick.bind(this);\n    this.handleDownloadOnClick = this.handleDownloadOnClick.bind(this);\n  }\n\n  handleTryOnClick() {\n    this.input.current.value = \"https://purl.stanford.edu/jt466yc7169\";\n  }\n\n  handleDownloadOnClick() {\n    const url = this.input.current.value;\n    const { hostname, path } = URLParse(url);\n    if (hostname === \"purl.stanford.edu\") {\n      const proxy = 'https://cors-anywhere.herokuapp.com/';\n      const feed = `${proxy}https://searchworks.stanford.edu/catalog.json?f%5Bcollection%5D%5B%5D=${path.slice(1)}&per_page=${this.maxDownloadFiles}`;\n      fetch(feed, { method: 'GET' })\n        .then(response => {\n          this.setState({progress: 0});\n          return response.json();\n        })\n        .then(jsonFeed => {\n          return jsonFeed.response.docs.flatMap(doc => `${doc.url_fulltext}/iiif/manifest`);\n        })\n        .then(manifests => {\n          console.log(manifests)\n          manifests.forEach(manifest => {\n            this.retrieveManifest(manifest);\n          })\n        });\n    }\n  }\n\n  downloadZip() {\n    console.log(this.state.docs);\n    this.zip.generateAsync({type:\"blob\"}).then(function (blob) {\n        saveAs(blob, \"collection.zip\");\n    }, function (err) {\n        console.log(err);\n    });\n  }\n\n  addTextToZip(label, texts) {\n    console.log(`${label}\\n-------------------`)\n    Promise.all(texts.map(promise => promise.catch(err => err)))\n    .then(textChunks => {\n      const text = textChunks.join(\" \");\n      this.setState({\n        docs: [{label, text}, ...this.state.docs],\n        progress: this.state.progress + 1\n      });\n      this.zip.file(`${label}.txt`, text);\n      if (this.state.progress === this.maxDownloadFiles) {\n        this.downloadZip();\n      }\n    })\n    .catch(e => console.log(e));\n  }\n\n  retrieveManifest(manifestUri) {\n    getPDFsFromIIIFManifest(manifestUri).then(pdfFiles => {\n      pdfFiles.map(pdfFile => {\n        PdfJsLib.getDocument(pdfFile.uri).then((pdf) => {\n          const texts = [...Array(pdf._pdfInfo.numPages).keys()].map(pageNumber => (\n            pdf.getPage(pageNumber + 1).then(pdfPage => (\n              pdfPage.getTextContent().then(textContent => (\n                textContent.items.map(text => text.str).join(\" \")\n              ))\n            ))\n          ));\n          this.addTextToZip(pdfFile.label, texts);\n        });\n      })\n    })\n  }\n\n  render() {\n    const progress = (this.state.progress !== null && this.state.progress !== this.maxDownloadFiles ) ? (\n      <progress min={0} max={this.maxDownloadFiles} value={this.state.progress} />\n    ) : ('');\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            To download the available plain texts of a collection,\n            enter its URL and click on Download (only the first {this.maxDownloadFiles} items will be retrieved)\n          </p>\n          <p>\n            <input ref={this.input} />\n            <input type=\"submit\" onClick={this.handleDownloadOnClick} value=\"Download\" />\n          </p>\n          <small>\n            Try the <a href=\"#\" onClick={this.handleTryOnClick}>\n              Jarndyce Single-Volume Nineteenth-Century Novel Collection, 1823-1914\n            </a>.\n          </small>\n          {progress}\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/logo.1e0f9ac8.svg\";"],"sourceRoot":""}